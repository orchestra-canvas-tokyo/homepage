# 作業内容

ユーザはClineよりプログラミングが得意ですが、時短のためにClineにコーディングを依頼しています。

2回以上連続でテストを失敗した時は、現在の状況を整理して、一緒に解決方法を考えます。

私は GitHub
から学習した広範な知識を持っており、個別のアルゴリズムやライブラリの使い方は私が実装するよりも速いでしょう。テストコードを書いて動作確認しながら、ユーザーに説明しながらコードを書きます。

反面、現在のコンテキストに応じた処理は苦手です。コンテキストが不明瞭な時は、ユーザーに確認します。

ユーザーから指示を受け取ったら、以下のプロセスに従って作業を進めてください：

---

0. 作業開始準備

`git status` で現在の git のコンテキストを確認します。
もし指示された内容と無関係な変更が多い場合、現在の変更からユーザーに別のタスクとして開始するように提案してください。

無視するように言われた場合は、そのまま続行します。

1. 指示の分析と計画
<タスク分析>
- 主要なタスクを簡潔に要約してください。
- 記載された技術スタックを確認し、その制約内での実装方法を検討してください。
- 重要な要件と制約を特定してください。
- 潜在的な課題をリストアップしてください。
- タスク実行のための具体的なステップを詳細に列挙してください。
- それらのステップの最適な実行順序を決定してください。

### 重複実装の防止
実装前に以下の確認を行ってください：
- 既存コンポーネントの再利用可能性
- その他、src/lib/ 内のユーティリティ関数の活用
- 共通のスタイル定義（/src/app.html）の利用

このセクションは、後続のプロセス全体を導くものなので、時間をかけてでも、十分に詳細かつ包括的な分析を行ってください。
</タスク分析>

---

2. タスクの実行
- 特定したステップを一つずつ実行してください。
- 各ステップの完了後、簡潔に進捗を報告してください。
- 実装時は以下の点に注意してください：
    - src/lib/components/ 内のコンポーネント構造の一貫性維持
    - TypeScriptの型定義の厳密な管理
    - 既存ロジックの整合性確保

---

3. 品質管理と問題対応
- 各タスクの実行結果を迅速に検証してください。
- エラーや不整合が発生した場合は、以下のプロセスで対応してください：
    a. TypeScriptコンパイルエラーの確認と修正
    b. ビルドエラーの解決
    c. linter / prettierの実行とエラー解決
    d. コンポーネントのレンダリング検証
    e. ロジックの正確性確認
- 検証結果は以下の形式で記録してください：
    a. 検証項目と期待される結果
    b. 実際の結果と差異
    c. 必要な対応策（該当する場合）

---

4. 最終確認
- すべてのタスクが完了したら、成果物全体を評価してください。
- 当初の指示内容との整合性を確認し、必要に応じて調整を行ってください。
- 実装した機能に重複がないことを最終確認してください。
- 多言語対応の完全性を確認してください。
- 今回の作業を踏まえて、clinrulesへ追加すべき内容があったら、ユーザーへ提案してください。**clinerulesは勝手に書き換えずに必ずユーザーの承認をとってください。**

---

5. 結果報告
以下のフォーマットで最終的な結果を報告してください：
```markdown
# 実行結果報告

## 概要
[全体の要約を簡潔に記述]

## 実行ステップ
1. [ステップ1の説明と結果]
2. [ステップ2の説明と結果]
...

## 最終成果物
[成果物の詳細や、該当する場合はリンクなど]

## 課題対応（該当する場合）
- 発生した問題と対応内容
- 今後の注意点

## 注意点・改善提案
- [気づいた点や改善提案があれば記述]
```

6. Git コミット
- タスク完了後は必ず変更内容をgitコミットしてください。
- git add する前に必ず git status を実行し、予定外の変更が加わっていることがわかったら修正してください。
- 変更内容を確認したら、`git add .` を使用して全ての変更をステージングしてください。
- コミットメッセージは以下の形式に従ってください：
  ```
  <type>: <description>
  ```
  
  typeには以下のいずれかを使用してください：
  - feat: 新機能の追加
  - fix: バグ修正
  - docs: ドキュメントの変更
  - style: コードスタイルの変更（フォーマットなど）
  - refactor: リファクタリング
  - test: テストコードの追加・修正
  - chore: ビルドプロセスやツールの変更
  
  descriptionは日本語で、変更内容を簡潔に記述してください。
  
  例：
  - `feat: ヘッダーコンポーネントを追加`
  - `fix: ナビゲーションのリンク切れを修正`
  - `test: Breadcrumbコンポーネントのテストを追加`

## 重要な注意事項
- 必ず日本語で回答してください。
- SvelteおよびSvelteKitのドキュメントはsvelte-docs-small.mdに記載しています。ClineはSvelteに不慣れで、初学者です。必ずこの内容を参照しながら実装を進め、わからないことがあったら都度Web検索を行うか、ユーザーに確認を行ってください。他のフレームワーク等で得た知識から推測で記述を進めるのは厳禁です。
- node_modulesの内容は読み込まずに無視すること
- .gitignoreに含まれるファイルの内容は読み込まずに無視すること
- 不明点がある場合は、作業開始前に必ず確認を取ってください。
- 重要な判断が必要な場合は、その都度報告し、承認を得てください。
- 予期せぬ問題が発生した場合は、即座に報告し、対応策を提案してください。
- 一定のタスクが完了した場合はgitコミットを行ってください。
- .envは読まないこと
- 秘匿情報はgitにコミットしないこと
- プロンプトを必ず含めること
- 実装した内容をリスト形式で書き記すこと
- 明示的に指示されていない変更は行わないでください。
- 一定以上複雑なロジックの変更は慎重に行い、必ず承認を得てください。

# 技術スタック

## コア技術
- TypeScript
- Svelte
- SvelteKit

## 開発ツール
- Prettier (コード整形)
- eslint (linter)
- npm
- Vitest (テスト)

# テスト規則

## テストファイルの配置と命名

テスト対象のファイルと同一のディレクトリに `__tests__`ディレクトリを作成し、その中にテスト対象ファイルと同名のテストファイルを配置する（例：`./[FileName].svelte` のテストは `./__tests__/[FileName].test.ts`）。

## テストの基本原則

1. **仕様のドキュメント化**
   - テストコードは「動く仕様書」として機能させる
   - itブロックの説明文を読むだけでコンポーネントの機能が理解できるようにする
   - コンポーネント仕様の概要を冒頭のコメントブロックに記載する

2. **テストの粒度と範囲**
   - 「機能」単位でテストを作成する（複数の小さな検証を含むことがあっても良い）
   - 典型的な使用パターンを重視し、実際のユースケースに基づいたテストを優先する
   - 類似するテストケースや重複する検証は統合し、テストの数を最小限に抑える
   - CSSの細かな挙動や実装詳細ではなく、コンポーネントの機能的な振る舞いをテストする

3. **テスト構造と分類**
   - describeブロックでテストを論理的にグループ化する
   - 第一階層はコンポーネント名（例：'Breadcrumb.svelte'）
   - 第二階層は機能カテゴリ（例：'基本構造'、'リンク機能'）
   - itブロックでテストケースを記述（日本語で明確に）

4. **テストカバレッジ**
   - 行カバレッジ100%を目指すが、無意味なテストは書かない
   - 網羅的なテストより意味のあるテストを優先する
   - 典型的なユースケースが網羅されているかを重視する

## 効率的なテスト作成手順

1. **コンポーネントの分析**
   - コンポーネントの目的と主要機能を特定
   - 典型的なユースケースと基本機能を洗い出す

2. **テスト計画**
   - 機能カテゴリを特定（3-5程度が理想）
   - 各カテゴリで検証すべきテストケースを決定（少数の意味のあるテストに集中）

3. **テスト実装**
   - 各テストは独立して実行できるように設計
   - 基本的な機能テストから始め、複雑なケースへ進む
   - それぞれのテストの意図をコメントで明記

4. **検証と改良**
   - テストを実行して成功を確認（`npm test`）
   - カバレッジを確認（`npm run test:coverage`）
   - コードの可読性と保守性を考慮してリファクタリング

## テスト実装のベストプラクティス

1. **モックの適切な使用**
   - 外部ライブラリやAPIはモックして外部依存を分離する
   - プロジェクト内部のコンポーネントやモジュールはモックせず、実際の動作をテストする
   - テスト環境で再現困難な機能（ブラウザAPIなど）のみ必要に応じてモック化する

2. **コンポーネントテスト**
   - 機能の核心をテストし、実装詳細には依存しない
   - UIの細かな実装詳細（CSSやHTML属性）ではなく機能的な振る舞いをテストする
   - 内部コンポーネントの実装に依存せず、公開インターフェースを重視する
   - コンポーネントの責務と意図に焦点を当て、表面的な出力確認を超えたテストを設計する
   - データの整合性、順序、関係性など、コンポーネントが担う本質的な機能を確実に検証する

3. **テストの構造**
   - 各テストはArrange（準備）→Act（実行）→Assert（検証）の明確な流れで構成する
   - テストコメントも上記の構造に従って記述し、何を準備し、何を実行し、何を検証しているかを明示する
   - 曖昧な表現（「適切に」など）を避け、具体的に検証内容を記述する
   - 1つのitブロック内で配列やループを使って複数のテストケースを実行する実装は避ける
     - 理由1: テスト失敗時に具体的にどのケースが失敗したか特定しにくい
     - 理由2: エラーメッセージがわかりにくく、デバッグが困難になる
     - 理由3: 各テストケースの意図が明確に表現されない
   - 複数の類似したテストを行う場合でも、各機能に対して独立した明確なitブロックを作成する

4. **テストの焦点**
   - 機能ごとに独立したテストケースを作成し、1つのテストでは1つの機能に集中する
   - 基本的な使用シナリオに集中し、エッジケースの過剰なテストは避ける
     - エッジケース/コーナーケースかどうかは、実際のユースケースとして通常考えうる内容かどうかで判断する
     - コンポーネントのプロパティのデフォルト値やよく使われる値の組み合わせはエッジケースではなく、基本的な使用シナリオとして必ずテストする
     - 実際に使用されるパターンを重視し、それらを優先的にテストする
     - コード上可能だが実際のアプリケーションで発生しにくい状況のテストは最小限に留める
   - 見た目のスタイルよりも機能的な振る舞いを重視する

5. **テストの独立性**
   - 各テストが他のテストに依存しないようにする
   - テスト順序に依存しない設計
   - 共通のセットアップはbeforeEach内で行う

6. **テストメンテナンス**
   - コンポーネント変更時にはテストも更新
   - 小さなリファクタリングでテストが壊れる場合は、テストが実装詳細に依存している可能性がある
   - テストコードの品質もレビュー対象とする

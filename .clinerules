# 重要

ユーザはClineよりプログラミングが得意ですが、時短のためにClineにコーディングを依頼しています。

2回以上連続でテストを失敗した時は、現在の状況を整理して、一緒に解決方法を考えます。

ClineはGitHubから学習した広範な知識を持っており、個別のアルゴリズムやライブラリの使い方はユーザーが実装するよりも速いでしょう。
テストコードを書いて動作確認しながら、ユーザーに説明しながらコードを書きます。

反面、現在のコンテキストに応じた処理は苦手です。
コンテキストが不明瞭な時は、ユーザーに確認します。

ユーザーから指示を受け取ったら、以下のプロセスに従って作業を進めてください：

---

0. 作業開始準備

`git status` で現在の git のコンテキストを確認します。
もし指示された内容と無関係な変更が多い場合、現在の変更からユーザーに別のタスクとして開始するように提案してください。

無視するように言われた場合は、そのまま続行します。

1. 指示の分析と計画
- 主要なタスクを簡潔に要約
- 記載された技術スタックを確認し、その制約内での実装方法を検討
- 重要な要件と制約を特定
- 潜在的な課題をリストアップ
- タスク実行のための具体的なステップを詳細に列挙
- それらのステップの最適な実行順序を決定
- 不明点がある場合は、作業開始前に必ず確認

ここが一番重要。
時間をかけてでも、十分に詳細かつ包括的な分析を行う。

---

2. タスクの実行
- 特定したステップを一つずつ実行
- 各ステップの完了後、簡潔に進捗を報告
- 既存ロジックとの重複実装を避ける
- 既存ロジックの改変時はデグレリスクを十分検討

---

3. 品質管理と問題対応
- 以下の点をすべて必ず検証する。Clineはコードロジックを見ただけでは以下の点を判断できない。
   a. TypeScriptコンパイルエラーの確認と修正
   b. ビルドエラーの解決
   c. linter / prettierの実行とエラー解決（`npm run lint:eslint` / `npm run format`）
   d. 実際に起動してブラウザでのレンダリング確認
   e. ロジックの正確性確認
- 検証結果は以下の形式で記録する
   a. 検証項目と期待される結果
   b. 実際の結果と差異
   c. 必要な対応策（該当する場合）

---

4. 最終確認
- 当初の指示内容との整合性を確認し、必要に応じて調整
- 実装した機能に重複がないことを最終確認
- 今回の作業を反省し、clinrulesへ追加すべき内容があったら、ユーザーへ提案
   - **clinerulesは勝手に書き換えずに必ずユーザーの承認をとってください。**

---

5. 結果報告
以下のフォーマットで最終的な結果を報告してください：
```markdown
# 実行結果報告

## 概要
[全体の要約を簡潔に記述]

## 実行ステップ
1. [ステップ1の説明と結果]
2. [ステップ2の説明と結果]
...

## 最終成果物
[成果物の詳細や、該当する場合はリンクなど]

## 課題対応（該当する場合）
- 発生した問題と対応内容
- 今後の注意点

## 注意点・改善提案
- [気づいた点や改善提案があれば記述]
```

6. Git コミット
- タスク完了後は必ず変更内容をgitコミットしてください。
- git add する前に必ず git status を実行

### Gitルール
  ```
  <type>: <description>
  ```
  
  typeには以下のいずれかを使用してください：
  - feat: 新機能の追加
  - fix: バグ修正
  - docs: ドキュメントの変更
  - style: コードスタイルの変更（フォーマットなど）
  - refactor: リファクタリング
  - test: テストコードの追加・修正
  - chore: ビルドプロセスやツールの変更
  
  descriptionは日本語で、変更内容を簡潔に記述
  
  例：
  - `feat: ヘッダーコンポーネントを追加`
  - `fix: ナビゲーションのリンク切れを修正`
  - `test: Breadcrumbコンポーネントのテストを追加`

## 重要な注意事項
- 必ず日本語で回答してください。
- SvelteおよびSvelteKitのドキュメントはsvelte-docs-small.mdに記載しています。ClineはSvelteに不慣れで、初学者です。必ずこの内容を参照しながら実装を進め、わからないことがあったら都度Web検索を行うか、ユーザーに確認を行ってください。他のフレームワーク等で得た知識から推測で記述を進めるのは厳禁です。
- .gitignoreに含まれるファイルの内容は読み込まずに無視すること
- .envを読むのは禁止
- 秘匿情報はgitにコミットするのを禁止
- プロンプトを必ず含めること
- 実装した内容をリスト形式で書き記す
- 明示的に指示されていない変更は禁止
- 一定以上複雑なロジックの変更を独断で行うのは禁止、必ず承認を得る

# 技術スタック

## コア技術
- TypeScript
- Svelte
- SvelteKit

## 開発ツール
- Prettier (コード整形)
- eslint (linter)
- npm
- Vitest (テスト)

# テスト規則

## テストファイルの配置と命名

テスト対象のファイルと同一のディレクトリに `__tests__`ディレクトリを作成。
その中にテスト対象ファイルと同名のテストファイルを配置する（例：`./[FileName].svelte` のテストは `./__tests__/[FileName].test.ts`）。

## テストの基本原則

1. **仕様のドキュメント化**
   - テストコードは「動く仕様書」として機能させる
   - describeブロックでテストを論理的にグループ化する（例：'基本構造'、'リンク機能'）
   - itブロックの説明文を読むだけでコンポーネントの機能が理解できるようにする
      - 曖昧な表現（「適切に」など）を避け、具体的に検証内容を記述する

2. **テストの粒度と範囲**
   - 「機能」単位でテストを作成する（複数の小さな検証を含むことがあっても良い）
   - 典型的な使用パターンを重視し、実際のユースケースに基づいたテストを優先する
   - 内部実装に依存せず、公開インターフェースを重視する
   - ロジックをテストする。CSSの細かな挙動や実装詳細は見ない。
   - 基本的な使用シナリオに集中し、エッジケースの過剰なテストは避ける
     - エッジケース/コーナーケースかどうかは、実際のユースケースとして通常考えうる内容かどうかで判断する
     - コンポーネントのプロパティのデフォルト値やよく使われる値の組み合わせはエッジケースではなく、基本的な使用シナリオとして必ずテストする
     - コード上可能だが実際のアプリケーションで発生しにくい状況のテストは最小限に留める

3. **テストの構造**
   - 各テストはArrange（準備）→Act（実行）→Assert（検証）の明確な流れで構成
   - テストコメントも上記の構造に従って記述
   - **複数のテストケースを一つのitブロックにまとめるのは厳禁**
   - **テストケースは明確に分離し、各itブロックが単一の明確な目的を持つようにする**
   - **テスト対象の動作が似ていても、検証する機能が異なる場合は別々のitブロックで実装する**

4. **テストカバレッジ**
   - 行カバレッジ・分岐カバレッジ100%を目指すが、無意味なテストは書かない
   - 網羅的なテストより意味のあるテストを優先する
   - 典型的なユースケースが網羅されているかを重視する

5. **テストの独立性**
   - 古典学派を採用。ロンドン学派的な過剰モックは禁止。
   - APIやDBなどプロセス外依存は分離する
   - ローカルマシンで動くものは基本的にもっくしない。ただし共有依存は禁止。各テストは独立。

6. **テストメンテナンス**
   - コンポーネント変更時にはテストも更新
   - 小さなリファクタリングでテストが壊れる場合は、テストが実装詳細に依存している可能性がある
   - テストコードの品質もレビュー対象とする

## テスト作成の手順

1. **コンポーネントの分析**
   - コンポーネントの目的と主要機能を特定
   - 典型的なユースケースと基本機能を洗い出す

2. **テスト計画**
   - 機能カテゴリを特定（3-5程度が理想）
   - 各カテゴリで検証すべきテストケースを決定（少数の意味のあるテストに集中）

3. **テスト実装**
   - 各テストは独立して実行できるように設計
   - 基本的な機能テストから始め、複雑なケースへ進む
   - それぞれのテストの意図をコメントで明記

4. **検証と改良**
   - テストを実行して成功を確認（`npm test`）
   - カバレッジを確認（`npm run test:coverage`）
   - コードの可読性と保守性を考慮してリファクタリング
